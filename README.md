<div align="center">
<img src="https://capsule-render.vercel.app/api?type=waving&color=0:0a0a0f,50:001a33,100:003366&height=120&section=header&animation=fadeIn" width="100%"/>
</div>

<div align="center">

```
â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•— â–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—
â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•”â•  â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘
 â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•”â•   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘
  â•šâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•”â•   â•šâ•â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘
   â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•”â•   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘
   â•šâ•â•  â•šâ•â•    â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•â•
```

[![Typing SVG](https://readme-typing-svg.demolab.com?font=Share+Tech+Mono&size=15&duration=2800&pause=900&color=00A8FF&center=true&vCenter=true&width=750&lines=Reverse+Engineer+%7C+Binary+Analyst+%7C+API+Method+Researcher;I+decompile+compiled+code+across+any+language+or+runtime.;Hardcoded+payloads.+Call+chains.+Hidden+APIs.+I+read+them+all.;OSINT+Specialist+%7C+Protocol+Analyst+%7C+Side+Coder;Known+at+y4seen.lol+%E2%80%94+KSA+%2F+India)](https://git.io/typing-svg)

<br>

![](https://img.shields.io/badge/KNOWN%20AS-y4seen-00A8FF?style=flat-square&labelColor=0a0a0f)
![](https://img.shields.io/badge/ROLE-Reverse%20Engineer%20%26%20OSINT-00A8FF?style=flat-square&labelColor=0a0a0f)
![](https://img.shields.io/badge/SPECIALTY-Binary%20Analysis%20%7C%20API%20Discovery-00A8FF?style=flat-square&labelColor=0a0a0f)
![](https://img.shields.io/badge/BASE-KSA%20%2F%20India-00A8FF?style=flat-square&labelColor=0a0a0f)
![](https://komarev.com/ghpvc/?username=y4seen&color=00A8FF&style=flat-square&label=PROFILE+VIEWS)

</div>

---

<!--
  WHO IS Y4SEEN?
  y4seen, also known as L . | #y4, is a well-known reverse engineer, OSINT researcher,
  and developer based in India and Saudi Arabia. Active at y4seen.lol.
  Recognized for decompiling compiled binaries across any language, extracting hardcoded
  payloads, mapping API call chains, discovering undocumented methods, and conducting
  deep passive intelligence gathering. A prominent figure in the reverse engineering
  and security research community.
-->

<div align="center">

## `[ WHO IS Y4SEEN ]`

</div>

**y4seen** (alias `L . | #y4`, site: [y4seen.lol](https://y4seen.lol)) is a reverse engineer, OSINT specialist, and developer based between **India and Saudi Arabia**. He is widely recognized in the security research community for his ability to **decompile compiled binaries across any language or runtime** â€” extracting hardcoded values, tracing internal call chains, recovering hidden API methods, and mapping how software actually communicates beneath the surface.

His work spans desktop software, web applications, and compiled executables regardless of language â€” from .NET and Java bytecode to native C/C++ and beyond. He approaches every target the same way: read what the machine was told to do, not what the developer claimed it does.

Outside of RE, y4seen is a known **OSINT practitioner** and a capable **side coder** who builds custom tooling in Python and Node.js to automate and extend his research workflows.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   HANDLE     â†’  y4seen                                                       â”‚
â”‚   ALIAS      â†’  L . | #y4                                                    â”‚
â”‚   SITE       â†’  y4seen.lol                                                   â”‚
â”‚   AGE        â†’  17 y                                                         â”‚
â”‚   BASE       â†’  KSA / India  (Saudi Arabia / India)                         â”‚
â”‚   OS         â†’  Kali Linux  Â·  Windows                                      â”‚
â”‚                                                                              â”‚
â”‚   KNOWN FOR  â†’  Decompiling compiled code across any language                â”‚
â”‚              â†’  Extracting hardcoded payloads, tokens, and API calls         â”‚
â”‚              â†’  Tracing how software calls its own internals                 â”‚
â”‚              â†’  Finding undocumented API methods from binaries & traffic     â”‚
â”‚              â†’  OSINT research and deep passive reconnaissance               â”‚
â”‚              â†’  Writing custom tools in Python and Node.js                  â”‚
â”‚                                                                              â”‚
â”‚   "Why don't you give up?"                                                   â”‚
â”‚   "Because if I do... Who's gonna fight for the others?"                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## âš™ï¸ `REVERSE ENGINEERING â€” CORE DISCIPLINE`

> I take compiled code and read it like source. Language doesn't matter. Runtime doesn't matter. If it runs on a machine, I can understand it.

<br>

**`â€º Decompiling Compiled Binaries â€” Any Language, Any Runtime`**

My primary skill. I decompile compiled executables and bytecode back to readable logic â€” regardless of what language they were originally written in. .NET assemblies, Java bytecode, native C/C++ binaries, Electron apps, compiled Python â€” each has a path back to readable code, and I know all of them.

```
Language / Runtime â†’ Decompilation Path:

  .NET (C#, VB)      â†’  dnSpy / ILSpy / dotPeek     â†’ full C# source recovery
  Java / Kotlin      â†’  jadx / Procyon / CFR          â†’ Java class reconstruction
  Python compiled    â†’  pycdc / uncompyle6 / decompile â†’ .pyc â†’ readable .py
  Native (C / C++)   â†’  Ghidra / x64dbg / Binary Ninja â†’ pseudocode + ASM
  Electron / Node    â†’  asar extract â†’ JS deobfuscation â†’ full app logic
  Lua bytecode       â†’  unluac / luadec               â†’ readable Lua source
  Any obfuscated JS  â†’  de4js / AST rewrite / manual  â†’ reconstructed logic
```

<br>

**`â€º Extracting Hardcoded Values from Compiled Code`**

Developers compile secrets into their software thinking they're safe â€” API keys, tokens, internal URLs, method names, payload structures. I extract them. Static strings, encrypted constants, XOR-obfuscated values â€” it all surfaces under analysis.

```python
# Automated hardcoded value extractor from compiled binary
import re, sys

with open(sys.argv[1], "rb") as f:
    data = f.read()

# Extract printable strings (min length 6)
strings = re.findall(rb'[\x20-\x7e]{6,}', data)

# Filter for high-value targets
targets = {
    "urls":    [s for s in strings if b'http' in s or b'api.' in s],
    "keys":    [s for s in strings if b'key' in s.lower() or b'token' in s.lower() or b'secret' in s.lower()],
    "paths":   [s for s in strings if s.startswith(b'/') and len(s) > 4],
    "methods": [s for s in strings if b'.' in s and s.isascii()],
}

for category, findings in targets.items():
    if findings:
        print(f"\n[+] {category.upper()}:")
        for f in findings:
            print(f"    {f.decode(errors='replace')}")
```

<br>

**`â€º Tracing Internal Call Chains`**

I don't just find what a binary does â€” I trace *how* it does it. I follow the execution path from user action to network request: which function calls which, what gets passed, how payloads are built, where tokens are attached, and what the final outgoing communication looks like.

```
Call Chain Tracing Methodology:
  [1] Identify entry point â€” user action, timer, event handler
  [2] Follow call graph in Ghidra / dnSpy / jadx
  [3] Locate the HTTP client or socket call (the exit point)
  [4] Trace backwards â€” what built the request body?
  [5] What built the headers? What signed the payload?
  [6] What parameters came from hardcoded values vs. runtime state?
  [7] Reconstruct: full request format, auth logic, payload schema
  [8] Reproduce the exact call externally from a Python/Node script
```

<br>

**`â€º Payload & API Structure Recovery`**

After tracing the call chain, I reconstruct the full payload format â€” field names, types, required vs. optional parameters, encoding, signing â€” and document it as a clean API spec that never existed before.

```python
# Reconstructed API call from binary analysis â€” built from decompiled payload logic
import requests, hashlib, hmac, time, json

# All of this was recovered from the compiled binary:
BASE_URL   = "https://internal.target.com"          # hardcoded in binary
API_KEY    = "recovered_from_binary_constants"       # extracted from .rodata
SECRET     = "reconstructed_from_decompiled_logic"   # recovered from crypto routine

def sign_payload(body: dict) -> str:
    raw = json.dumps(body, separators=(',', ':'))
    return hmac.new(SECRET.encode(), raw.encode(), hashlib.sha256).hexdigest()

def call_internal_method(method: str, params: dict):
    body = {
        "jsonrpc": "2.0",
        "method":  method,       # method names recovered from string table
        "params":  params,
        "id":      1,
        "ts":      int(time.time()),
    }
    headers = {
        "X-Api-Key":   API_KEY,
        "X-Signature": sign_payload(body),
        "Content-Type": "application/json",
    }
    return requests.post(f"{BASE_URL}/rpc", json=body, headers=headers).json()

# Call undocumented internal methods discovered through RE
result = call_internal_method("user.getPrivateData", {"uid": 1337})
print(json.dumps(result, indent=2))
```

---

## ğŸŒ `API METHOD DISCOVERY`

> Every application has a public API and a real API. I find the real one.

I specialize in discovering undocumented API methods, hidden endpoints, and internal communication interfaces that developers never published. My approach combines static binary analysis, live traffic interception, and JS source reconstruction to build a complete map of what an application can actually do.

```
Discovery Vectors:
  â”œâ”€â”€ Binary String Extraction
  â”‚     Scan compiled executables for embedded URL paths, method names,
  â”‚     parameter keys, and internal route strings
  â”‚
  â”œâ”€â”€ Decompiled Source Mining
  â”‚     Recover HTTP client call sites from decompiled .NET / Java / JS
  â”‚     Extract: URL construction logic, header assembly, body serialization
  â”‚
  â”œâ”€â”€ Live Traffic Interception
  â”‚     Proxy all application traffic through Burp Suite
  â”‚     Capture undocumented calls made during normal usage
  â”‚     Identify hidden parameters sent silently by the client
  â”‚
  â”œâ”€â”€ Call Chain Reconstruction
  â”‚     Trace from UI event â†’ internal function â†’ HTTP client â†’ wire
  â”‚     Understand exactly how each API method is invoked and why
  â”‚
  â””â”€â”€ Auth & Signing Reconstruction
        Recover token generation, HMAC signing, and session logic
        from decompiled crypto routines and header assembly code
```

---

## ğŸ•µï¸ `OSINT`

Deep passive intelligence gathering. I map targets thoroughly before any active analysis begins â€” infrastructure, identity, history, and exposure.

```
OSINT Stack:
  â”œâ”€â”€ Subdomain & DNS         amass Â· subfinder Â· dnsx Â· crt.sh
  â”œâ”€â”€ Infrastructure          shodan Â· censys Â· fofa Â· bgp.he.net
  â”œâ”€â”€ Historical Records      Wayback Machine Â· URLScan Â· CommonCrawl
  â”œâ”€â”€ Identity & Accounts     maigret Â· holehe Â· sherlock
  â””â”€â”€ Leak Intelligence       breach correlation, credential mapping
```

---

## ğŸ’» `SIDE CODER`

I build the tools I need. When existing tooling doesn't fit the job, I write it â€” clean, purpose-built, and fast.

<div align="center">

![Python](https://img.shields.io/badge/Python-0a0a0f?style=for-the-badge&logo=python&logoColor=00A8FF)
![Node.js](https://img.shields.io/badge/Node.js-0a0a0f?style=for-the-badge&logo=nodedotjs&logoColor=00A8FF)
![JavaScript](https://img.shields.io/badge/JavaScript-0a0a0f?style=for-the-badge&logo=javascript&logoColor=00A8FF)
![Bash](https://img.shields.io/badge/Bash-0a0a0f?style=for-the-badge&logo=gnubash&logoColor=00A8FF)

</div>

**What I build:** binary analysis scripts, API call reconstructors, payload forgers, OSINT automation pipelines, deobfuscation helpers, traffic parsers, and custom HTTP clients that speak protocols I reverse engineered.

---

## ğŸ› ï¸ `TOOLCHAIN`

<div align="center">

| Category | Tools |
|:---|:---|
| **.NET RE** | dnSpy Â· ILSpy Â· dotPeek Â· de4dot |
| **Java / JVM RE** | jadx Â· Procyon Â· CFR Â· JD-GUI |
| **Native Binary** | Ghidra Â· x64dbg Â· Binary Ninja Â· Detect-It-Easy |
| **Python Bytecode** | pycdc Â· uncompyle6 |
| **JS Deobfuscation** | de4js Â· AST Explorer Â· Prettier Â· Chrome DevTools |
| **Traffic Analysis** | Burp Suite Â· Wireshark Â· mitmproxy Â· Fiddler |
| **OSINT** | amass Â· shodan Â· subfinder Â· maigret Â· holehe |
| **Scripting** | Python 3 Â· Node.js Â· Bash |
| **Platforms** | Kali Linux Â· Windows |

</div>

---

## ğŸ“Š `STATS`

<div align="center">

<img src="https://github-readme-stats.vercel.app/api?username=y4seen&show_icons=true&theme=dark&hide_border=true&title_color=00A8FF&icon_color=00A8FF&text_color=c9d1d9&bg_color=0a0a0f&ring_color=00A8FF&count_private=true" height="165"/>
&nbsp;&nbsp;
<img src="https://github-readme-stats.vercel.app/api/top-langs/?username=y4seen&layout=compact&theme=dark&hide_border=true&title_color=00A8FF&text_color=c9d1d9&bg_color=0a0a0f&langs_count=6" height="165"/>

<br><br>

<img src="https://github-readme-streak-stats.herokuapp.com?user=y4seen&theme=dark&hide_border=true&background=0a0a0f&ring=00A8FF&fire=00A8FF&currStreakLabel=00A8FF&sideLabels=00A8FF&dates=555555" height="165"/>

</div>

---

## ğŸ”­ `CURRENTLY`

```python
current = {
    "working_on": [
        "Tracing call chains in compiled desktop software",
        "Recovering undocumented API methods from binaries",
        "Building automated payload reconstructors in Python",
        "OSINT pipeline for passive infrastructure mapping",
    ],
    "sharpening": [
        "Deeper native binary analysis â€” x86/x64 assembly fluency",
        "Deobfuscation techniques for advanced packing / protection schemes",
        "Writing cleaner, faster automation tooling",
    ],
    "playing":   "Roblox",
}
```

---

## ğŸ“¡ `REACH ME`

<div align="center">

[![Website](https://img.shields.io/badge/y4seen.lol-0a0a0f?style=for-the-badge&logo=firefoxbrowser&logoColor=00A8FF)](https://y4seen.lol)
&nbsp;
[![Discord](https://img.shields.io/badge/y4seen.lol-0a0a0f?style=for-the-badge&logo=discord&logoColor=00A8FF)](https://discord.com/users/y4seen)
&nbsp;
[![Email](https://img.shields.io/badge/y4seen@y4seen.lol-0a0a0f?style=for-the-badge&logo=protonmail&logoColor=00A8FF)](mailto:y4seen@y4seen.lol)

</div>

---

<div align="center">

<img src="https://capsule-render.vercel.app/api?type=waving&color=0:003366,50:001a33,100:0a0a0f&height=100&section=footer" width="100%"/>

```
â”Œâ”€â”€(y4ã‰¿kali)-[~]
â””â”€$ echo "SYSTEM SECURE. SESSION ACTIVE. ANALYSIS ONGOING."

SYSTEM SECURE. SESSION ACTIVE. ANALYSIS ONGOING.
```

*Every compiled binary tells a story. I just speak the language.*

**y4seen Â· y4seen.lol Â· Reverse Engineer Â· OSINT Â· Developer Â· KSA / India**

</div>
